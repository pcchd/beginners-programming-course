* Lecture 1
** What we'll learn by the end of the course
  - Computational thinking

    Write small pieces of code that do useful things

  - Understand code written by others

    It is super useful to read code written by others

  - Understand our abilities and limit

  - Take description of a problem, and convert it into a programming problem

** Computation
- Declarative knowledge
  - Tells you *what* something is, not *how* to do it
  - Closest it gets is allow us to *test* it

  e.g
  #+BEGIN_EXAMPLE
  \sqrt{x} is a number ~y~ s.t y^2 = x and y != 0
  #+END_EXAMPLE

- Imperative knowledge
  - Tells us *how* to do something
  - A sequence of instructions to do something

  e.g
  #+BEGIN_EXAMPLE
  - Start with a guess ~g~
  - If g^2 = x, stop, return g
  - else g = (g + x/g) / 2
  - repeat
  #+END_EXAMPLE

- *computation* is about capturing the process of coming up with imperative process to do something

- A computation is based on a fixed set of primitives which are used to create complex computation
** Programming Language

- There is no best programming-language,
  but some languages are better at doing certain things than other languages

- Language used in this course is Python,
  but the course is not about Python. It is about how to program, Python is only a programming language
  choice and once we know how to code in one language (Python in our case), we can learn a new language
  easily

- Different dimensions of a language

  - _High vs Low level_

    Low level: Very close to hardware. Primitives are moving data from one location in memory to other
    High level: Much richer set of primitives

  - _General vs targeted_

    General: For general purpose programming. Can be used to do a /lot/ of things e.g Python
    Targeted: Designed for a specific purpose, e.g Maths (Matlab)

  - _Interpreted vs Compiled_

    Interpreted: Interpreter work directly on source-code at runtime
    Compiled: Compiler compiles code to intermediate form (Object Code) which actually runs finally

- Python is
  - High level
  - General Purpose
  - Interpreted

- *Syntax of a language*

  What are the legal expressions in this language

- *Static Semantics of a language*

  says which programs are meaningful i.e which expressions make sense

- *Semantics of a language*

  says what a program means, i.e what happens when the program runs
* Lecture 2
:LOGBOOK:
CLOCK: [2016-12-29 Thu 16:37]
:END:
- Two things needed to write programs:
  - Representing data
    - Value and Type
  - Give instructions to manipulate that data
    - Expressions: operands and operators
** Python
- Operators are overloaded
  i.e same operators work on different types
  e.g
  #+BEGIN_SRC python
    3 * 3
    # 9

    'as' * 3
    # 'asasas'

    'a' + 's'
    # 'as'
  #+END_SRC

- Python *does not* automatically convert types
  #+BEGIN_SRC python
    3 + 's'
    # error
  #+END_SRC

  We have to convert the types ourselves
   #+BEGIN_SRC python
    str(3) + 's'
    # '3s'
   #+END_SRC

  But Python is not very strict and it is possible to make silly mistakes:
  So we have to take care while mixing types (type discipline).

- *Operator Precedence*
  - Operators have their priority order in which they operate
  - Use parenthesis to change the order of operators (parenthesis are executed first)

- *Variables*

  Variables have their own values which is given to them using ~=~ (assignment) operator e.g
  #+BEGIN_SRC python
  x = 4 * 3
  #+END_SRC

  Python executes the expression on right, and bind name on left to the place in memory which saves that value.

- *Statements*
  Legal commands that python can interpret. e.g print, assignment (=)

- *Branching programs*
  choose the order of instructions based on some test

  Syntax:
  #+BEGIN_SRC python
  if <condition>:
    <true block>:
  else:
    <false block>
  #+END_SRC

  - Boolean Combinations: /and/, /or/, /not/

    | Input 1 | Input 2 | And   | Or    | Not(of Input 1) |
    |---------+---------+-------+-------+-----------------|
    | True    | True    | True  | True  | False           |
    | True    | False   | False | True  | False           |
    | False   | True    | False | True  | True            |
    | False   | False   | False | False | True            |

  - In Python, everything except *False, 0, None, '', [], {}* is True
* Lecture 3
- Looping in Iterative Programs
  - initialize it outside the loop
  - setup end test (variable)
  - construct the block of code
    - change count variable
  - what to do when done

- Complexity of a loop depends on its input

- Defensive programming
  - If you are getting input from users, don't expect them to always provide correct input (user's mistakes)
  - Put a lot of tests to check there are no bugs (programmer's mistakes)

- Exhaustive enumeration
  - Try all reasonable values until the solution is found

- *for* loop

  #+BEGIN_EXAMPLE
  for <var> in <some collection>:
    <block of code>
  #+END_EXAMPLE

- *Tuple*
  - ordered sequence of elements
  - it is immutable

  #+BEGIN_SRC python
  foo = (1, 2, 3, 4)
  #+END_SRC

- Python syntax
  - Tuples and getting values out of them
  - Adding tuples
  - List slices
* Lecture 4
- *Decomposition*
  - a way of putting structure on code
  - breaking the code into modules
- *Abstraction*
  - hide details
- *Functions*
  - break code into modules
  - suppress details
  - create "new primitives"
  - It is a good practice to have a return at every end of the branch in a function
  - Function is invoked by providing input in parenthesis next to function name
- *Scope*
  - Environment in which a variable binding is visible
  - Functions have their own private scope
- *Brute force algorithm*
  - Try all possible inputs and check the result
- *Recursion*
  - Break the problem into simpler version of same problem, plus some steps to add their solutions to
    make solution of the whole problem
  - *Base case*
    Simplest possible solution to our problem
  - *Recursive step*
    - break the problem into simpler version of same problem, and glue steps to combine small solutions

  e.g
  #+BEGIN_SRC python
    def isPalindrome(string):
      if len(string) <= 1:
        return True
      else:
        return string[0] == string[-1] and isPalindrome(string[1:-1])
  #+END_SRC

  #+BEGIN_SRC python
    def fib(x):
        if x == 0 or x == !:
            return 1
        else:
            return fib(x - 1) + fib(x - 2)
  #+END_SRC
* Lecture 5
- *int*
  - Integers in python are arbitrary precision
    i.e numbers can be of any length
  - Dealing with long integers is less efficient than dealing with small integers
  - Very long numbers in Python are represented in "long" format
- *float*
  - Python uses IEEE 754 floating point scientific notation
    - Numbers are represented in the form of ~Mentissa * Exponent~
  - 64 bit computers allow up to 17 decimal digits of precision
- *Successive approximation*
  - Rough structure for all algorithms that follow this
    - start with an initial guess
      - Iterate for an exhaustive test
        - if ~f(x)~ is close enough, return guess
        - else get a better guess
    - Throw error if above iteration didn't get an answer
  - Bisection method

    We have our solutions in sorted linear storage

    - Make the middle of the list initial guess
    - If guess < middle, do same in left
    - If guess > middle, do same in right
    - Repeat until there are no more items or we get the result
* Lecture 6
- /Regression Testing/
  - Put tests for checking that program don't go backward i.e from working right to wrong after changes
- /Speed of convergence/
  - How fast the answer is found with bisection methods
- Tuples and Strings are immutable in python
* Lecture 7
- *Dictionary*
  - Mutable
  - Not ordered
  - Generalized Indexing
  - <key,value>
- Write pseudo-code before starting to write actual code
- Efficiency is about choice of algorithms
- It is hard to come up with new clever/efficient algorithms
- We measure two things for efficiency
  - Space
  - Time
- We measure efficiency as: the number of basic steps needed as a function of the input size
  - We assume that things computer do like accessing memory, doing basic calculations take constant time
- We measure efficiency for following cases:
  - Best Case
  - Worst Case
  - Average/expected Case
* Lecture 8
- Rate of growth of complexity as the size of the problem grows
  - *Asymptotic notation*
    - We ignore additive and multiplicative constants when calculating asymptotic complexity
      i.e
      #+BEGIN_EXAMPLE
      4 + n = n
      4n = n
      #+END_EXAMPLE
      It doesn't matter how big the constants are, we simply ignore them.
    - *Big Oh Notation*
      - Upper limit to the growth of a function as the input gets large
      - Worse possible case for an algorithm
      - Example
        $f(x) \in O(n^2)$
    - *Classes of complexity*
      Since we ignore additive and multiplicative constants in asymptotic complexity, we can come up with
      some general classes of complexity
      - *Logarithmic*
        When we reduce the problem size by a multiplicative factor e.g reduce it by half
      - *Linear*
        When we reduce the problem size by one at a time
      - *Quadratic*
        When we process input multiple times
      - *Exponential*
    - Just because an algorithm is bad in asymptotic complexity, doesn't mean it will always be bad
      than one which is better. Asymptotic complexity tell us about /general/ case
* Lecture 9
- It is not possible to sort a list in sub linear (i.e ~< n~) time.
  Because we have to look at each element at least once
- Best we can do to sort a list is ~n log(n)~
* Lecture 10
- *Divide and Conquer*
- Split the problem into several sub problems of same type
- solve each sub-problem independently
- combine the solutions

  - *Merge Sort*
    - Divide list in half
    - continue until we have single item lists
    - merge the sorted lists

- *Hashing*
  - Constant time access to data
  - Trade off space for time
* Lecture 11
- *Validation*
  Process to uncover problems and increase confidence
- *Debugging*
  Process of ascertaining why a program is not working
- *Testing*
  Process of examining input/output pairs
  - *Unit Testing*
    Validate each piece of the program independently e.g Functions, Classes
  - *Integration Testing*
    Overall validation of the whole program
  - It is not possible to test /all/ the possibilities. So we choose a test suite
  - A Test Suit is small enough to be feasible to run, but large enough to give some confidence
* Lecture 12
 - Problem reduction
   When given a problem to solve, check what similar problem have other people already solved
 - Optimization Problems
   Most optimization problems consists
   - A function that needs to be maximized or minimized
   - A set of constraints that must be respected
   e.g Shortest path
 - Greedy Algorithms
   - For every step, maximize the value for that step without any consideration for future
   - Makes locally optimum decisions
* Lecture 13
- *Memoization*
  - Record a value when it is computed the first time, then reuse it when same computation need to be done again
  - Useful to improve programs which deal with overlapping sub-problems
    - Overlapping Sub-problems
      When while solving a problem by recursion (i.e by dividing it into sub-problems), the sub-problems overlap i.e
      same sub-problems need solved more than once.
- Optimal Substructure
  Global optimal solution  be constructed from optimal solutions to sub-problems
- *Decision Tree*
  Decision Tree is a binary-tree data-structure which is used to figure out outcomes of an algorithm
